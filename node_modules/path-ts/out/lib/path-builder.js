/**
 * @copyright Sister Software
 * @license AGPL-3.0
 * @author Teffen Ellis, et al.
 */
/* eslint-disable @typescript-eslint/no-wrapper-object-types */
/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */
import { resolve as _resolve, basename, dirname } from "node:path";
/**
 * Runtime class identifier for the PathBuilder class.
 *
 * @internal
 */
export const kPathBuilder = Symbol.for("PathBuilder");
/**
 * Type-safe path builder.
 */
export class PathBuilder extends URL {
    /**
     * Runtime class identifier for the PathBuilder class.
     *
     * @internal
     */
    [kPathBuilder] = true;
    [Symbol.hasInstance](instance) {
        return instance[kPathBuilder] === true;
    }
    /**
     * Directory name of a path. Similar to the Unix dirname command.
     */
    dirname() {
        return PathBuilder.from(dirname(this.toString()));
    }
    /**
     * Base name of a path. Similar to the Unix basename command.
     */
    basename() {
        return PathBuilder.from(basename(this.toString()));
    }
    /**
     * Get the current path as a string.
     */
    toString() {
        return this.pathname;
    }
    constructor(path, base = "file://") {
        super(path, base);
    }
    get [Symbol.toStringTag]() {
        return this.toString();
    }
    get length() {
        return this.toString().length;
    }
    [Symbol.toPrimitive]() {
        return this.toString();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.toString();
    }
    static from(pathBuilderLike, ...pathSegmentN) {
        if (pathSegmentN.length === 0 && pathBuilderLike instanceof PathBuilder) {
            return pathBuilderLike;
        }
        const joinedPath = _resolve(
        // ---
        pathBuilderLike.toString(), ...pathSegmentN.map((pathSegment) => pathSegment.toString()));
        const pathBuilderInstance = new PathBuilder(joinedPath);
        const toString = pathBuilderInstance.toString.bind(pathBuilderInstance);
        const PathBuilderProxy = new Proxy(PathBuilder.from, {
            apply(target, _thisArg, args) {
                return target(joinedPath, ...args);
            },
            get(target, prop) {
                switch (prop) {
                    case Symbol.toPrimitive:
                    case Symbol.for("nodejs.util.inspect.custom"):
                    case "toString":
                    case "valueOf":
                        return toString;
                    case "name":
                        return "PathBuilderProxy";
                }
                if (prop === Symbol.toStringTag)
                    return toString();
                if (prop in pathBuilderInstance) {
                    return pathBuilderInstance[prop];
                }
                return target[prop];
            },
            getPrototypeOf() {
                return PathBuilder.prototype;
            },
            [Symbol.for("nodejs.util.inspect.custom")]() {
                return "PathBuilder";
            },
        });
        Object.assign(PathBuilderProxy, {
            [Symbol.for("nodejs.util.inspect.custom")]: () => pathBuilderInstance.pathname,
        });
        return PathBuilderProxy;
    }
}
for (const [propertyName, propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors(String.prototype))) {
    if (propertyName === "constructor")
        continue;
    if (propertyName === "toString")
        continue;
    if (propertyName === "valueOf")
        continue;
    if (propertyName === "length")
        continue;
    if (Object.hasOwn(URL.prototype, propertyName))
        continue;
    try {
        Object.defineProperty(PathBuilder.prototype, propertyName, propertyDescriptor);
    }
    catch (e) {
        console.error(`Failed to assign property ${propertyName} to PathBuilder prototype:`, e);
    }
}
export default PathBuilder;
//# sourceMappingURL=path-builder.js.map